-e 
// ----------------------------
//
// DependencyContainer.swift
//
// ----------------------------

//
//  DependencyContainer.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//
import Foundation
import Combine
 // Replace 'AndroLaunch' with your project's main module name

final class DependencyContainer {
    static let shared = DependencyContainer()

    // Services
    private lazy var adbService: ADBServiceProtocol = ADBService()
    private lazy var scrcpyService: ScrcpyServiceProtocol = ScrcpyService() // Correct initialization
    
    // Repositories
    private lazy var deviceRepository: any DeviceRepositoryProtocol = DeviceRepository(
        adbService: adbService,
        scrcpyService: scrcpyService // Pass scrcpyService
    )

    lazy var menuViewModel: MenuViewModel = MenuViewModel(
        deviceRepository: deviceRepository
    )
}


// ----------------------------
//
// AppConstants.swift
//
// ----------------------------

//
//  AppConstants.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//
import Foundation

enum AppConstants {
    static let adbPaths: [String] = [
        "/usr/local/bin/adb", // Homebrew
        "/opt/homebrew/bin/adb", // Homebrew (Apple Silicon)
        "/usr/bin/adb", // System default (less common)
        "~/.android-sdk/platform-tools/adb", // Example user path
        "/Users/\(NSUserName())/Library/Android/sdk/platform-tools/adb" // Standard Android Studio path
        // Add more potential paths here if necessary
    ].map { ($0 as NSString).expandingTildeInPath } // Expand the tilde (~)
    
    static let scrcpyPaths = [
        "/opt/homebrew/bin/scrcpy",
        "/usr/local/bin/scrcpy",
        "\(NSHomeDirectory())/.local/bin/scrcpy",
        "/Applications/scrcpy.app/Contents/MacOS/scrcpy"
    ]
}


// ----------------------------
//
// AppDelegate.swift
//
// ----------------------------

//
//  AppDelegate.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import SwiftUI

final class AppDelegate: NSObject, NSApplicationDelegate {
    private var statusMenuController: StatusMenuController?
    private var settingsWindow: NSWindow?
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        NSApp.setActivationPolicy(.accessory)
        let container = DependencyContainer.shared
        statusMenuController = StatusMenuController(viewModel: container.menuViewModel)
    }
    
    func openPreferences() {
        // Create window if needed
        if settingsWindow == nil {
            let settingsView = PreferencesView()
                .environmentObject(DependencyContainer.shared.menuViewModel)
            
            settingsWindow = NSWindow(
                contentRect: NSRect(x: 0, y: 0, width: 480, height: 300),
                styleMask: [.titled, .closable, .miniaturizable],
                backing: .buffered,
                defer: false
            )
            settingsWindow?.contentViewController = NSHostingController(rootView: settingsView)
            settingsWindow?.title = "Preferences"
        }
        
        // Bring to front
        settingsWindow?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }
}


// ----------------------------
//
// AppMain.swift
//
// ----------------------------

//
//  AppMain.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import SwiftUI

@main
struct AndroLaunch: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate: AppDelegate
    
    var body: some Scene {
        // Main window group - required even for menu bar apps
        WindowGroup(id: "main") {
            EmptyView()
                .frame(width: 0, height: 0)
                .hidden()
        }
        .windowStyle(.hiddenTitleBar)
        .defaultSize(width: 0, height: 0)
        
        // Settings scene
        Settings {
            PreferencesView()
                .environmentObject(DependencyContainer.shared.menuViewModel)
        }
    }
}


// ----------------------------
//
// DeviceRepository.swift
//
// ----------------------------

//
//  DeviceRepository.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Foundation
import Combine
import SwiftUI // Import SwiftUI for ObservableObject

    final class DeviceRepository: DeviceRepositoryProtocol { // Conform to the protocol defined in Domain

    // @Published properties. These automatically provide a publisher ($propertyName).
    // These properties are internal to the repository's state management.
    @Published var devices: [AndroidDevice] = []
    @Published var apps: [AndroidApp] = [] // Assuming AndroidApp is also defined in Domain or a shared module
    @Published var error: String? = nil // Changed to String? as per your code
    @Published var isLoading: Bool = false

    // Implement the publisher requirements from the protocol
    // These provide external access to the published data via the protocol.
    public var errorPublisher: AnyPublisher<String?, Never> { $error.eraseToAnyPublisher() }
    public var devicesPublisher: AnyPublisher<[AndroidDevice], Never> { $devices.eraseToAnyPublisher() }
    public var appsPublisher: AnyPublisher<[AndroidApp], Never> { $apps.eraseToAnyPublisher() } // Assuming AndroidApp is defined
    public var isLoadingPublisher: AnyPublisher<Bool, Never> { $isLoading.eraseToAnyPublisher() }


    // Dependencies (assuming these protocols are defined elsewhere, e.g., in a Service layer)
    private let adbService: ADBServiceProtocol // Assuming ADBServiceProtocol is defined elsewhere
    private let scrcpyService: ScrcpyServiceProtocol // Assuming ScrcpyServiceProtocol is defined elsewhere
    private var cancellables = Set<AnyCancellable>()

    // Initialize with dependencies
    init(adbService: ADBServiceProtocol, scrcpyService: ScrcpyServiceProtocol) {
        self.adbService = adbService
        self.scrcpyService = scrcpyService
        setupBindings()
    }

    // Setup bindings to observe the ADBService
        private func setupBindings() {
            adbService.devices
                .receive(on: DispatchQueue.main)
                .sink { [weak self] devices in
                    self?.devices = devices
                    self?.isLoading = false
                }
                .store(in: &cancellables)

        // Observe apps from adbService
        // Assuming adbService.apps publishes [AndroidApp]
        adbService.apps
            .receive(on: DispatchQueue.main)
            .sink { [weak self] (apps: [AndroidApp]) in // Explicit type annotation
                self?.apps = apps
            }
            .store(in: &cancellables)

        adbService.error
            .receive(on: DispatchQueue.main)
            .sink { [weak self] (error: String?) in // Explicit type annotation
                self?.error = error
                // Set isLoading to false when an error occurs during device refresh
                if error != nil && self?.isLoading == true {
                    self?.isLoading = false
                }
            }
            .store(in: &cancellables)

    }

    // MARK: - DeviceRepositoryProtocol Methods

        func refreshDevices() {
            isLoading = true
            adbService.findADB()
        }

        func fetchApps(for deviceID: String) {
            adbService.fetchApps(for: deviceID)
            // Clear previous apps when fetching new ones
            DispatchQueue.main.async {
                self.apps = []
            }
        }
    func launchApp(packageID: String, deviceID: String) {
        adbService.launchApp(packageID: packageID, deviceID: deviceID)
        // Handle potential errors from launching the app
    }

    func mirrorDevice(deviceID: String) {
        adbService.mirrorDevice(deviceID: deviceID)
        // Handle potential errors from mirroring the device
    }
        
        
}


// ----------------------------
//
// ADBServiceProtocol.swift
//
// ----------------------------

//
//  ADBServices.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

//
//  ADBServiceProtocol.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Foundation
import Combine
// import SwiftUI // Only import SwiftUI if needed for the protocol itself,
                 // not for structs/classes defined elsewhere

// --- ADBService Protocol Definition ---
protocol ADBServiceProtocol {
    // Publishers for reactive updates
    var devices: PassthroughSubject<[AndroidDevice], Never> { get }
    var apps: PassthroughSubject<[AndroidApp], Never> { get }
    var error: PassthroughSubject<String?, Never> { get }

    // Methods to be implemented by conforming types
    func findADB() // Discover ADB path and start daemon
    func listDevices() // List connected devices
    func startADBDaemon() // Start the ADB server
    func fetchApps(for deviceID: String) // Fetch apps for a specific device
    func launchApp(packageID: String, deviceID: String) // Launch an app on a device
    func mirrorDevice(deviceID: String)
}
// --- End ADBService Protocol Definition ---

// Remove the definitions for AndroidDevice, AndroidApp, ScrcpyServiceProtocol,
// and DeviceRepositoryProtocol if they are currently in this file.
// They should be in their own respective files.


// ----------------------------
//
// ADBService.swift
//
// ----------------------------

//
//  ADBService.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Combine
import Foundation
#if canImport(AppKit)
import AppKit // Needed for NSAlert and NSWorkspace
#endif

// MARK: - ADB Service Implementation

final class ADBService: ADBServiceProtocol {
    // MARK: - Protocol Requirements (Publishers)
    let devices = PassthroughSubject<[AndroidDevice], Never>()
    let apps = PassthroughSubject<[AndroidApp], Never>()
    let error = PassthroughSubject<String?, Never>()

    // MARK: - Internal State
    private var currentADBPath: String?
    private var cancellables = Set<AnyCancellable>()

    // State for managing scrcpy processes and error reporting
    private var scrcpyErrorPipeHandlers: [String: Any] = [:] // Dictionary to hold observation tokens/handlers keyed by device ID
    private var scrcpyErrorOutputs: [String: String] = [:] // Dictionary to collect error output keyed by device ID
    private var runningScrcpyProcesses: [String: Process] = [:] // To keep track of running scrcpy processes

    // MARK: - Executable Path Discovery

    // Common system paths for ADB
    private var systemADBPaths: [String] {
        [
            "/opt/homebrew/bin/adb", // Homebrew default
            "/usr/local/bin/adb",    // Older Homebrew or manual install
            "/usr/bin/adb",          // Sometimes in system path (less common for adb)
            "\(NSHomeDirectory())/Library/Android/sdk/platform-tools/adb", // Android Studio SDK default
            "/Library/Android/sdk/platform-tools/adb" // System-wide SDK? (less common)
        ]
    }

    // Common system paths for SCRCPY
    private var scrcpyPaths: [String] {
        [
            "/opt/homebrew/bin/scrcpy", // Homebrew default
            "/usr/local/bin/scrcpy",    // Older Homebrew or manual install
            "\(NSHomeDirectory())/.local/bin/scrcpy", // User bin
            "/Applications/scrcpy.app/Contents/MacOS/scrcpy" // App bundle location
        ]
    }

    // MARK: - Initialization
    init() {
        print("ADBService: Initializing...")
        // Initial ADB discovery can be triggered here or externally.
        // For this setup, it's assumed to be called by refreshDevices() or similar.
    }

    // MARK: - Private Helper: Execute Shell Command (For ADB commands like list, start-server, fetch packages)
    private func executeADBCommand(arguments: [String], path: String? = nil, completion: @escaping (Bool, String?, String?) -> Void) {
        guard let adbPath = path ?? currentADBPath else {
            print("ExecuteADBCommand failed: ADB executable path not set.")
            completion(false, nil, "ADB executable path not set.")
            return
        }

        let task = Process()
        task.executableURL = URL(fileURLWithPath: adbPath)
        task.arguments = arguments

        let standardOutputPipe = Pipe()
        let standardErrorPipe = Pipe()
        task.standardOutput = standardOutputPipe
        task.standardError = standardErrorPipe

        // Use a background queue for the potentially long-running process
        DispatchQueue.global(qos: .background).async {
            do {
                try task.run()
                // Wait for ADB commands to finish. This is appropriate for non-interactive commands.
                task.waitUntilExit()

                let outputData = standardOutputPipe.fileHandleForReading.readDataToEndOfFile()
                let errorData = standardErrorPipe.fileHandleForReading.readDataToEndOfFile()

                let output = String(data: outputData, encoding: .utf8)
                let errorOutput = String(data: errorData, encoding: .utf8)

                // Deliver the result back to the main thread
                DispatchQueue.main.async {
                    print("Executed ADB Command: \(adbPath) \(arguments.joined(separator: " "))") // Debug print
                    print("Output: \(output ?? "nil")") // Debug print
                    print("Error: \(errorOutput ?? "nil")") // Debug print
                    print("Termination Status: \(task.terminationStatus)") // Debug print

                    let success = task.terminationStatus == 0 // Basic check

                    completion(success, output, errorOutput)
                }
            } catch {
                DispatchQueue.main.async {
                    print("Process execution error for \(adbPath) \(arguments.joined(separator: " ")): \(error.localizedDescription)") // Debug print
                    completion(false, nil, error.localizedDescription)
                }
            }
        }
    }

    // MARK: - Private Helper: Find SCRCPY Executable
    private func findScrcpyPath() -> String? {
         print("Attempting to find scrcpy...")
         for path in scrcpyPaths {
             print("Checking scrcpy path: \(path)")
             if FileManager.default.fileExists(atPath: path) && FileManager.default.isExecutableFile(atPath: path) {
                 print("SCRCPY found at: \(path)")
                 return path
             }
         }
         print("SCRCPY not found in any specified paths.")
         return nil
     }


    // MARK: - ADB Path Discovery
    func findADB() {
        print("Attempting to find ADB...")
        for path in systemADBPaths { // Use system paths from this service
            print("Checking path: \(path)")
            if FileManager.default.isExecutableFile(atPath: path) {
                print("ADB found at: \(path)")
                currentADBPath = path
                error.send(nil) // Clear previous ADB not found error
                startADBDaemon() // Start daemon once found
                return
            }
        }
        print("ADB not found in any specified paths.")
        let notFoundError = "ADB not found. Install Android Platform Tools."
        error.send(notFoundError)
        devices.send([]) // Ensure device list is empty if ADB not found
        currentADBPath = nil
    }

    func startADBDaemon() {
        guard let adbPath = currentADBPath else {
             print("Cannot start daemon, ADB path not set.") // Debug print
            return // Should not happen if findADB was successful
        }
        print("Starting ADB daemon...")
        // Use executeADBCommand for the standard ADB start-server command
        executeADBCommand(arguments: ["start-server"], path: adbPath) { [weak self] success, _, errorOutput in
            guard let self else { return }
            if success {
                print("ADB daemon started successfully.")
                // Daemon might take a moment, add a small delay before listing devices
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { // Add a small delay
                     self.listDevices() // Proceed to list devices if daemon starts
                }
            } else {
                print("ADB daemon failed to start. Error: \(errorOutput ?? "Unknown error")")
                self.error.send(errorOutput ?? "ADB daemon failed to start")
                self.devices.send([]) // Send empty devices on error
            }
        }
    }

    // MARK: - Device Listing
    func listDevices() {
        guard currentADBPath != nil else {
            print("ADB path not set, cannot list devices.")
            // Error already sent by findADB or startADBDaemon
            return
        }
        print("Executing 'adb devices -l'...")
         // Use executeADBCommand for the standard ADB devices command
        executeADBCommand(arguments: ["devices", "-l"]) { [weak self] success, output, errorOutput in
            guard let self else { return }
            if success {
                print("Raw ADB devices output: \(output ?? "nil")")
                let devices = self.parseDevices(from: output ?? "")
                print("Parsed devices: \(devices)")
                self.devices.send(devices)
                self.error.send(nil) // Clear any previous errors on success
            } else {
                print("ADB devices command failed. Error: \(errorOutput ?? "Unknown error")")
                self.error.send(errorOutput ?? "Device listing failed")
                self.devices.send([]) // Send empty devices list on error
            }
        }
    }

    // MARK: - Private Helper: Parse ADB Devices Output
    private func parseDevices(from output: String) -> [AndroidDevice] {
        let pattern = #"^(\S+)\s+(device|unauthorized|offline|no permissions)\s*(.*)$"# // Adjusted regex slightly for end of line
        guard let regex = try? NSRegularExpression(pattern: pattern, options: .anchorsMatchLines) else {
             print("Failed to create regex for device parsing.")
            return []
        }
        var devices = [AndroidDevice]()

        output.enumerateLines { line, _ in
            guard !line.lowercased().contains("list of devices attached") && !line.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return } // Skip header and empty lines

            let range = NSRange(line.startIndex..., in: line)
            guard let match = regex.firstMatch(in: line, options: [], range: range),
                  match.numberOfRanges >= 3 else {
                 print("Line did not match device pattern: \(line)") // Debug unmatched lines
                return
            }

            let idRange = match.range(at: 1)
            let stateRange = match.range(at: 2)
            let detailsRange = match.range(at: 3) // Optional details range

            guard let id = Range(idRange, in: line),
                  let state = Range(stateRange, in: line) else {
                 print("Could not extract ID or state from line: \(line)")
                return
            }

            let deviceID = String(line[id])
            let deviceState = String(line[state])
            var modelName = "Android Device" // Default name

            if let detailsRng = Range(detailsRange, in: line) {
                let details = String(line[detailsRng])
                let modelPattern = #"model:([^\s]+)"#
                if let modelMatch = try? NSRegularExpression(pattern: modelPattern)
                    .firstMatch(in: details, range: NSRange(details.startIndex..., in: details)),
                    let modelRng = Range(modelMatch.range(at: 1), in: details) {
                    modelName = String(details[modelRng]).replacingOccurrences(of: "_", with: " ")
                }
            }

            // Only add devices that are successfully connected
            if deviceState == "device" {
                devices.append(AndroidDevice(
                    id: deviceID,
                    name: modelName,
                    isConnected: true // State is "device"
                ))
                 print("Found connected device: \(deviceID) (\(modelName))") // Debug found device
            } else {
                print("Found device in state \(deviceState): \(deviceID)") // Debug non-connected states
                // You could add devices in 'unauthorized' state with isConnected: false
                // devices.append(AndroidDevice(id: deviceID, name: modelName, isConnected: false))
            }
        }

        return devices // Returning all parsed devices, filter in VM/Repo if only 'device' state is needed
    }


    // MARK: - App Listing
    func fetchApps(for deviceID: String) {
         guard currentADBPath != nil else {
             self.error.send("ADB not found or not set.")
             self.apps.send([])
             return
         }
         print("Fetching apps for device: \(deviceID)")
         // Clear previous apps immediately on the main thread
         DispatchQueue.main.async {
             self.apps.send([])
         }

         // Use executeADBCommand for the standard ADB shell command
         // Added -3 to list only third-party apps, like in the DeviceManager example
         executeADBCommand(arguments: ["-s", deviceID, "shell", "pm", "list", "packages", "-3"], completion: { [weak self] success, output, errorOutput in
             guard let self else { return }
             if success {
                 // Basic parsing: extract package names
                 let packageLines = output?.split(separator: "
") ?? []
                 let apps = packageLines.compactMap { line -> AndroidApp? in
                     let lineString = String(line) // Ensure it's a String
                     if lineString.starts(with: "package:") {
                         let packageName = String(lineString.dropFirst("package:".count)).trimmingCharacters(in: .whitespacesAndNewlines) // Trim whitespace
                         // Use package name as the app name for now
                         return AndroidApp(id: packageName, name: packageName)
                     }
                     return nil
                 }
                 print("Fetched and parsed \(apps.count) apps.")
                 self.apps.send(apps)
                 self.error.send(nil) // Clear any previous errors on success
             } else {
                 print("Fetching apps failed. Error: \(errorOutput ?? "Unknown error")")
                 self.error.send(errorOutput ?? "Failed to fetch apps for \(deviceID)")
                 self.apps.send([])
             }
         })
     }

    // MARK: - App Launching & Mirroring (using SCRCPY)
    func launchApp(packageID: String, deviceID: String) {
        guard let adbPath = currentADBPath else {
            let errorMessage = "ADB executable path not set. Cannot launch app with scrcpy."
            print("LaunchApp failed: \(errorMessage)")
            self.error.send(errorMessage)
            // Optionally attempt to find ADB again
            self.findADB()
            return
        }

        guard let scrcpyPath = findScrcpyPath() else {
            let errorMessage = """
            SCRCPY executable not found.
            Please install scrcpy (e.g., `brew install scrcpy` on macOS).
            """
            print("LaunchApp failed: \(errorMessage)")
            self.error.send(errorMessage)
            // Optionally show an alert directly from here if needed, or rely on UI observing the error publisher
            #if canImport(AppKit)
            DispatchQueue.main.async {
                 let alert = NSAlert()
                 alert.messageText = "SCRCPY Not Found"
                 alert.informativeText = errorMessage + "

Common installation method on macOS:
Open Terminal and run: `brew install scrcpy`"
                 alert.addButton(withTitle: "OK")
                 alert.addButton(withTitle: "Open scrcpy GitHub")
                 alert.alertStyle = .warning
                 let response = alert.runModal()
                 if response == .alertSecondButtonReturn {
                     NSWorkspace.shared.open(URL(string: "https://github.com/Genymobile/scrcpy")!)
                 }
            }
            #endif
            return
        }

        print("Attempting to launch app \(packageID) on device \(deviceID) using scrcpy...")




        let task = Process()
        task.executableURL = URL(fileURLWithPath: scrcpyPath)
        task.arguments = [
            "--serial", deviceID,
            "--stay-awake",
            "--window-title", "Running: \(packageID)",
            "--new-display=720x1400", // Added resolution argument
            "--start-app", packageID
        ]

        var env = ProcessInfo.processInfo.environment
        env["ADB"] = adbPath // Explicitly tell scrcpy where to find adb
        // Ensure common binary paths are in the PATH for scrcpy if it needs other tools
        env["PATH"] = "/opt/homebrew/bin:/usr/local/bin:/usr/bin:\(env["PATH"] ?? "")"
        task.environment = env

        let errorPipe = Pipe()
        task.standardError = errorPipe
        let errorFileHandle = errorPipe.fileHandleForReading
        scrcpyErrorOutputs[deviceID] = "" // Initialize error output storage for this device

         if let obs = scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
             NotificationCenter.default.removeObserver(obs)
         }

        // Add an observer for data available on the error pipe
        let observer = NotificationCenter.default.addObserver(forName: FileHandle.readCompletionNotification, object: errorFileHandle, queue: nil) { [weak self] notification in
            guard let self else { return }
            if let data = notification.userInfo?[FileHandle.readCompletionNotification] as? Data, !data.isEmpty {
                if let output = String(data: data, encoding: .utf8) {
                    // Append collected output
                    self.scrcpyErrorOutputs[deviceID, default: ""] += output
                }
                errorFileHandle.readInBackgroundAndNotify()
            } else {
                 // End of file - scrcpy process likely terminated
                 print("End of SCRCPY error output for \(deviceID).")
                 // Clean up the observer for this device
                 if let obs = self.scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
                     NotificationCenter.default.removeObserver(obs)
                 }
            }
        }
        scrcpyErrorPipeHandlers[deviceID] = observer
        errorFileHandle.readInBackgroundAndNotify() // Start the first read

        // --- Run the Process ---
        do {
            try task.run()
            // Store the process reference
            runningScrcpyProcesses[deviceID] = task
            print("✅ SCRCPY process launched successfully for device \(deviceID) to launch app \(packageID).")


        } catch {
            // Error launching the process itself (e.g., scrcpy path invalid, permissions)
            let errorMessage = "Failed to launch SCRCPY process for \(deviceID): \(error.localizedDescription)"
            print("❌ \(errorMessage)")
            self.error.send(errorMessage)

            // Clean up error pipe reader if the process didn't even start
            if let obs = self.scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
                 NotificationCenter.default.removeObserver(obs)
             }
             scrcpyErrorOutputs[deviceID] = nil // Clear collected output

            #if canImport(AppKit)
            DispatchQueue.main.async {
                 let alert = NSAlert()
                 alert.messageText = "Launch Failed"
                 alert.informativeText = errorMessage
                 alert.addButton(withTitle: "OK")
                 alert.alertStyle = .critical
                 alert.runModal()
            }
            #endif
        }
    }

    // MARK: - Optional Mirroring Function
     // Mirrors the entire device screen using scrcpy (without launching a specific app)
     func mirrorDevice(deviceID: String) {
         guard let adbPath = currentADBPath else {
             let errorMessage = "ADB executable path not set. Cannot mirror device with scrcpy."
             print("MirrorDevice failed: \(errorMessage)")
             self.error.send(errorMessage)
             self.findADB() // Attempt to find ADB
             return
         }

         guard let scrcpyPath = findScrcpyPath() else {
             let errorMessage = """
             SCRCPY executable not found.
             Please install scrcpy (e.g., `brew install scrcpy` on macOS).
             """
             print("MirrorDevice failed: \(errorMessage)")
             self.error.send(errorMessage)
             #if canImport(AppKit)
             DispatchQueue.main.async {
                  // Show alert similar to launchApp
                  let alert = NSAlert()
                  alert.messageText = "SCRCPY Not Found"
                  alert.informativeText = errorMessage + "

Common installation method on macOS:
Open Terminal and run: `brew install scrcpy`"
                  alert.addButton(withTitle: "OK")
                  alert.addButton(withTitle: "Open scrcpy GitHub")
                  alert.alertStyle = .warning
                  let response = alert.runModal()
                  if response == .alertSecondButtonReturn {
                      NSWorkspace.shared.open(URL(string: "https://github.com/Genymobile/scrcpy")!)
                  }
             }
             #endif
             return
         }

         print("Attempting to mirror device \(deviceID) using scrcpy...")


         let task = Process()
         task.executableURL = URL(fileURLWithPath: scrcpyPath)

         // scrcpy arguments for mirroring
         task.arguments = ["--serial", deviceID, "--no-audio", "--window-title", "Mirroring \(deviceID)"]

         var env = ProcessInfo.processInfo.environment
         env["ADB"] = adbPath // Explicitly tell scrcpy where to find adb
         env["PATH"] = "/opt/homebrew/bin:/usr/local/bin:/usr/bin:\(env["PATH"] ?? "")"
         task.environment = env

         let errorPipe = Pipe()
         task.standardError = errorPipe

         let errorFileHandle = errorPipe.fileHandleForReading
         scrcpyErrorOutputs[deviceID] = ""

         // Remove any existing observer for this device before adding a new one
          if let obs = scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
              NotificationCenter.default.removeObserver(obs)
          }

         let observer = NotificationCenter.default.addObserver(forName: FileHandle.readCompletionNotification, object: errorFileHandle, queue: nil) { [weak self] notification in
              guard let self else { return }
              if let data = notification.userInfo?[FileHandle.readCompletionNotification] as? Data, !data.isEmpty {
                  if let output = String(data: data, encoding: .utf8) {
                      self.scrcpyErrorOutputs[deviceID, default: ""] += output
                      // print("SCRCPY Error Output (\(deviceID)): \(output.trimmingCharacters(in: .whitespacesAndNewlines))")
                  }
                  errorFileHandle.readInBackgroundAndNotify()
              } else {
                  print("End of SCRCPY error output for \(deviceID).")
                  if let obs = self.scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
                      NotificationCenter.default.removeObserver(obs)
                  }
              }
         }
         scrcpyErrorPipeHandlers[deviceID] = observer
         errorFileHandle.readInBackgroundAndNotify()

         task.terminationHandler = { [weak self] terminatedTask in
             DispatchQueue.main.async { [weak self] in
                 guard let self else { return }
                 let exitCode = terminatedTask.terminationStatus
                 print("SCRCPY process for \(deviceID) terminated with status \(exitCode)")

                 let collectedErrorOutput = self.scrcpyErrorOutputs[deviceID] ?? "No error output captured."

                 self.runningScrcpyProcesses[deviceID] = nil
                 self.scrcpyErrorOutputs[deviceID] = nil

                 if exitCode != 0 {
                     let errorMessage = "SCRCPY mirroring failed for device \(deviceID) (Exit code: \(exitCode)).
Error Output:
\(collectedErrorOutput.trimmingCharacters(in: .whitespacesAndNewlines))"
                     print("❌ \(errorMessage)")
                     self.error.send(errorMessage)
                     #if canImport(AppKit)
                     DispatchQueue.main.async {
                          let alert = NSAlert()
                          alert.messageText = "SCRCPY Mirroring Failed"
                          alert.informativeText = errorMessage
                          alert.addButton(withTitle: "OK")
                          alert.alertStyle = .critical
                          alert.runModal()
                     }
                     #endif
                 } else {
                     print("SCRCPY mirroring for \(deviceID) exited cleanly.")
                 }
                 if let obs = self.scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
                     NotificationCenter.default.removeObserver(obs)
                 }
             }
         }

         do {
             try task.run()
             runningScrcpyProcesses[deviceID] = task
             print("✅ SCRCPY mirroring process launched successfully for device \(deviceID).")

         } catch {
             let errorMessage = "Failed to launch SCRCPY mirroring process for \(deviceID): \(error.localizedDescription)"
             print("❌ \(errorMessage)")
             self.error.send(errorMessage)
             if let obs = self.scrcpyErrorPipeHandlers.removeValue(forKey: deviceID) as? NSObjectProtocol {
                  NotificationCenter.default.removeObserver(obs)
              }
              scrcpyErrorOutputs[deviceID] = nil
             #if canImport(AppKit)
             DispatchQueue.main.async {
                  let alert = NSAlert()
                  alert.messageText = "Mirroring Failed"
                  alert.informativeText = errorMessage
                  alert.addButton(withTitle: "OK")
                  alert.alertStyle = .critical
                  alert.runModal()
             }
             #endif
         }
     }

    private func showScrcpyErrorAlert(errorMessage: String) {
        #if canImport(AppKit)
        DispatchQueue.main.async {
            let alert = NSAlert()
            alert.messageText = "Action Failed"
            alert.informativeText = """
            \(errorMessage)

            Ensure scrcpy is installed and accessible in your system's PATH.
            Common installation method on macOS:
            Open Terminal and run: `brew install scrcpy`
            """
            alert.addButton(withTitle: "OK")
            alert.addButton(withTitle: "Open scrcpy GitHub")
            alert.alertStyle = .warning
            let response = alert.runModal()
            if response == .alertSecondButtonReturn {
                NSWorkspace.shared.open(URL(string: "https://github.com/Genymobile/scrcpy")!)
            }
        }
        #endif
    }
    // MARK: - Optional Stop Mirroring Function
    func stopMirroring(deviceID: String) {
        if let task = runningScrcpyProcesses[deviceID] {
            print("Attempting to terminate SCRCPY process for device \(deviceID)...")
            task.terminate() // Request termination
            // The terminationHandler will handle cleanup
        } else {
            print("No running SCRCPY process found for device \(deviceID).")
        }
    }
}


// ----------------------------
//
// ScrcpyServiceProtocol.swift
//
// ----------------------------

//
//  ScrcpyServiceProtocol.swift
//  AndroLaunch
//
//  Created by Aman Raj on 22/4/25.
//

import Foundation
import Combine

protocol ScrcpyServiceProtocol {
    var error: PassthroughSubject<String?, Never> { get }
    func mirrorDevice(deviceID: String, adbPath: String?)
    func launchApp(packageID: String, deviceID: String, adbPath: String?)
}


// ----------------------------
//
// ScrcpyService.swift
//
// ----------------------------

//
//  ScrcpyService.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Foundation
import Combine

// Ensure ScrcpyServiceProtocol is imported or defined where this file can access it

final class ScrcpyService: ScrcpyServiceProtocol {
    private var scrcpyPath: String?
    private var runningProcesses: [String: Process] = [:]
    let error = PassthroughSubject<String?, Never>()

    // Path discovery for scrcpy
    private func findScrcpyPath() -> String? {
        let paths = [
            "/opt/homebrew/bin/scrcpy",
            "/usr/local/bin/scrcpy",
            "\(NSHomeDirectory())/.local/bin/scrcpy",
            "/Applications/scrcpy.app/Contents/MacOS/scrcpy"
        ]
        for path in paths {
            if FileManager.default.isExecutableFile(atPath: path) {
                return path
            }
        }
        return nil
    }

    func mirrorDevice(deviceID: String, adbPath: String?) {
        guard let scrcpyPath = findScrcpyPath() else {
            error.send("SCRCPY not installed. Use `brew install scrcpy`.")
            return
        }
        // Launch scrcpy with deviceID and adbPath...
    }

    func launchApp(packageID: String, deviceID: String, adbPath: String?) {
        guard let scrcpyPath = findScrcpyPath() else {
            error.send("SCRCPY not installed. Use `brew install scrcpy`.")
            return
        }
        // Launch scrcpy with --start-app and packageID...
    }
}


// ----------------------------
//
// DeviceRepositoryProtocol.swift
//
// ----------------------------

//
//  DeviceRepositoryProtocol.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Combine
import SwiftUI

protocol DeviceRepositoryProtocol: ObservableObject {
    var objectWillChange: ObservableObjectPublisher { get }
    var errorPublisher: AnyPublisher<String?, Never> { get }
    var devicesPublisher: AnyPublisher<[AndroidDevice], Never> { get }
    var appsPublisher: AnyPublisher<[AndroidApp], Never> { get }
    var isLoadingPublisher: AnyPublisher<Bool, Never> { get }
    
    var devices: [AndroidDevice] { get }
    var apps: [AndroidApp] { get }
    var error: String? { get }
    var isLoading: Bool { get }
    
    func refreshDevices()
    func fetchApps(for deviceID: String)
    func launchApp(packageID: String, deviceID: String)
    func mirrorDevice(deviceID: String)
}


// ----------------------------
//
// AndroidDevice.swift
//
// ----------------------------

//
//  AndroidDevices.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Foundation

public struct AndroidDevice: Identifiable, Equatable {
    public let id: String
    public let name: String
    public let isConnected: Bool
    
    public init(id: String, name: String, isConnected: Bool) {
        self.id = id
        self.name = name
        self.isConnected = isConnected
    }
}


// ----------------------------
//
// AndroidApp.swift
//
// ----------------------------

//
//  AndroidApp.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Foundation

public struct AndroidApp: Identifiable, Codable, Equatable {
    public let id: String
    public let name: String
    public let iconName: String
    
    public init(id: String, name: String, iconName: String = "android") {
        self.id = id
        self.name = name
        self.iconName = iconName
    }
}


// ----------------------------
//
// PreferencesViewModel.swift
//
// ----------------------------

//
//  PreferencesViewModel.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import Foundation // Import Foundation for DispatchQueue
import Combine
import SwiftUI // Import SwiftUI for ObservableObject

// Import the protocol from the Domain layer
// If not a module, you might need a specific import like:
// import YourModuleName.DeviceRepositoryProtocol


// The repository instance must conform to DeviceRepositoryProtocol (which is ObservableObject)
final class PreferencesViewModel: ObservableObject {
    @Published var adbStatus: String = "Checking..."
    @Published var errorMessage: String?

    // The repository must conform to DeviceRepositoryProtocol (which inherits ObservableObject)
    // This protocol needs to explicitly expose 'errorPublisher'.
    internal let repository: any DeviceRepositoryProtocol
    private var cancellables = Set<AnyCancellable>()

    // Initialize with a repository that conforms to DeviceRepositoryProtocol
    init(deviceRepository: any DeviceRepositoryProtocol) {
        self.repository = deviceRepository
        setupObservers()
    }

    private func setupObservers() {
        // Observe the errorPublisher REQUIRED by DeviceRepositoryProtocol
        // This line REQUIRES DeviceRepositoryProtocol to define:
        // var errorPublisher: AnyPublisher<String?, Never> { get }
        repository.errorPublisher
            .receive(on: DispatchQueue.main)
            .sink { [weak self] (error: String?) in // Explicitly type the error parameter as String?
                print("PreferencesViewModel: Received error update: \(error ?? "nil")") // Added for debugging
                self?.adbStatus = error == nil ? "Connected" : "Error"
                self?.errorMessage = error
            }
            .store(in: &cancellables)

        // You might also want to observe the isLoadingPublisher if you want to show
        // a loading indicator in the preferences view.
        // This would require adding:
        // var isLoadingPublisher: AnyPublisher<Bool, Never> { get }
        // to the DeviceRepositoryProtocol.
        // repository.isLoadingPublisher
        //     .receive(on: DispatchQueue.main)
        //     .sink { [weak self] isLoading in
        //         print("PreferencesViewModel: Received isLoading update: \(isLoading)") // Added for debugging
        //         // Update a local @Published isLoading property if you have one
        //         // self?.isLoading = isLoading
        //     }
        //     .store(in: &cancellables)
    }

    // You might want methods here to trigger repository actions if needed by the preferences view,
    // e.g., a method to manually check ADB status.
    func checkAdbStatus() {
        print("PreferencesViewModel: Requesting refreshDevices to check status...") // Added for debugging
        repository.refreshDevices() // Refreshing devices often implies checking ADB status
    }
}


// ----------------------------
//
// PreferencesView.swift
//
// ----------------------------

//
//  PreferencesView.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import SwiftUI

struct PreferencesView: View {
    @EnvironmentObject var viewModel: PreferencesViewModel
    
    var body: some View {
        VStack(spacing: 20) {
            Text("ADB Status: \(viewModel.adbStatus)")
                .font(.headline)
            
            if let error = viewModel.errorMessage {
                Text("Error: \(error)")
                    .foregroundColor(.red)
            }
            
            Button("Check ADB Status") {
                viewModel.checkAdbStatus()
            }
        }
        .padding()
        .frame(width: 300, height: 200)
    }
}


// ----------------------------
//
// MenuViewModel.swift
//
// ----------------------------

//
//  MenuViewModel.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//


import Combine
import SwiftUI

final class MenuViewModel: ObservableObject {
    @Published var devices: [AndroidDevice] = []
    @Published var apps: [AndroidApp] = []
    @Published var error: String? = nil
    @Published var isLoading: Bool = false
    @Published var currentDeviceID: String? = nil
    
    internal let repository: any DeviceRepositoryProtocol
    private var cancellables = Set<AnyCancellable>()

    init(deviceRepository: any DeviceRepositoryProtocol) {
        self.repository = deviceRepository
        setupObservers()
    }

    private func setupObservers() {
        repository.devicesPublisher
            .receive(on: DispatchQueue.main)
            .assign(to: &$devices)
        
        repository.appsPublisher
            .receive(on: DispatchQueue.main)
            .assign(to: &$apps)
        
        repository.errorPublisher
            .receive(on: DispatchQueue.main)
            .assign(to: &$error)
        
        repository.isLoadingPublisher
            .receive(on: DispatchQueue.main)
            .assign(to: &$isLoading)
    }

    func refresh() { repository.refreshDevices() }
    func fetchApps(for deviceID: String) {
        currentDeviceID = deviceID
        repository.fetchApps(for: deviceID)
    }
    func launchApp(packageID: String, deviceID: String) { repository.launchApp(packageID: packageID, deviceID: deviceID) }
    func mirrorDevice(deviceID: String) { repository.mirrorDevice(deviceID: deviceID) }
}


// ----------------------------
//
// StatusMenuController.swift
//
// ----------------------------

//
//  StatusMenuController.swift
//  AndroLaunch
//
//  Created by Aman Raj on 21/4/25.
//

import AppKit
import Combine

final class StatusMenuController {
    private let statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
    private let viewModel: MenuViewModel
    private var cancellables = Set<AnyCancellable>()
    private var currentDeviceID: String?
    
    init(viewModel: MenuViewModel) {
        self.viewModel = viewModel
        setupMenu()
        bindViewModel()
    }
    
    private func setupMenu() {
        statusItem.button?.title = "AndroLaunch"
        refreshDevices() // Call once during setup
        updateMenu()
    }
    
    private func bindViewModel() {
        viewModel.$devices
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in self?.updateMenu() }
            .store(in: &cancellables)
        
        viewModel.$apps
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in self?.updateMenu() }
            .store(in: &cancellables)
        
        viewModel.$error
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in self?.updateMenu() }
            .store(in: &cancellables)
        
        viewModel.$isLoading
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in self?.updateMenu() }
            .store(in: &cancellables)
    }
    
    private func updateMenu() {
        let menu = NSMenu()
        
        // Header
        let headerItem = NSMenuItem(title: "AndroLaunch", action: nil, keyEquivalent: "")
        headerItem.isEnabled = false
        menu.addItem(headerItem)
        menu.addItem(NSMenuItem.separator())
        
        // Refresh Item
        let refreshItem = NSMenuItem(
            title: "Refresh Devices",
            action: #selector(refreshDevices),
            keyEquivalent: "r"
        )
        refreshItem.target = self
        menu.addItem(refreshItem)
        menu.addItem(NSMenuItem.separator())
        
        // Device List
        if viewModel.devices.isEmpty {
            let item = NSMenuItem(
                title: viewModel.error ?? "No devices found",
                action: nil,
                keyEquivalent: ""
            )
            item.isEnabled = false
            menu.addItem(item)
        } else {
            for device in viewModel.devices {
                let deviceItem = NSMenuItem(
                    title: "\(device.name) (\(device.id))",
                    action: nil,
                    keyEquivalent: ""
                )
                
                let submenu = NSMenu()
                
                // Mirror Action
                let mirrorItem = NSMenuItem(
                    title: "Mirror Device",
                    action: #selector(mirrorDevice),
                    keyEquivalent: ""
                )
                mirrorItem.target = self
                mirrorItem.representedObject = device.id
                submenu.addItem(mirrorItem)
                submenu.addItem(NSMenuItem.separator())
                
                // Apps Section
                if viewModel.isLoading && currentDeviceID == device.id {
                    let loadingItem = NSMenuItem(title: "Loading apps...", action: nil, keyEquivalent: "")
                    loadingItem.isEnabled = false
                    submenu.addItem(loadingItem)
                } else if device.id == currentDeviceID {
                    if viewModel.apps.isEmpty {
                        let noAppsItem = NSMenuItem(
                            title: viewModel.error ?? "No apps found",
                            action: nil,
                            keyEquivalent: ""
                        )
                        noAppsItem.isEnabled = false
                        submenu.addItem(noAppsItem)
                    } else {
                        viewModel.apps.forEach { app in
                            let appItem = NSMenuItem(
                                title: app.id,
                                action: #selector(launchApp),
                                keyEquivalent: ""
                            )
                            appItem.target = self
                            appItem.representedObject = (device.id, app.id)
                            submenu.addItem(appItem)
                        }
                    }
                    submenu.addItem(NSMenuItem.separator())
                    let refreshAppsItem = NSMenuItem(
                        title: "Refresh Apps",
                        action: #selector(refreshApps),
                        keyEquivalent: ""
                    )
                    refreshAppsItem.representedObject = device.id
                    refreshAppsItem.target = self
                    submenu.addItem(refreshAppsItem)
                } else {
                    let loadAppsItem = NSMenuItem(
                        title: "List Apps...",
                        action: #selector(loadApps),
                        keyEquivalent: ""
                    )
                    loadAppsItem.representedObject = device.id
                    loadAppsItem.target = self
                    submenu.addItem(loadAppsItem)
                }
                
                deviceItem.submenu = submenu
                menu.addItem(deviceItem)
            }
        }
        
        menu.addItem(NSMenuItem.separator())
        
        // Preferences
        let prefsItem = NSMenuItem(
            title: "Preferences...",
            action: #selector(showPreferences),
            keyEquivalent: ","
        )
        prefsItem.target = self
        menu.addItem(prefsItem)
        
        // Quit
        let quitItem = NSMenuItem(
            title: "Quit",
            action: #selector(NSApp.terminate(_:)),
            keyEquivalent: "q"
        )
        menu.addItem(quitItem)
        
        statusItem.menu = menu
    }
    
    // MARK: - Actions
    @objc private func refreshDevices() {
        viewModel.refresh()
        // Force immediate menu update
        DispatchQueue.main.async {
            self.updateMenu()
        }
    }
    
    @objc private func loadApps(_ sender: NSMenuItem) {
        guard let deviceID = sender.representedObject as? String else { return }
        currentDeviceID = deviceID
        viewModel.fetchApps(for: deviceID)
    }
    
    @objc private func refreshApps(_ sender: NSMenuItem) {
        guard let deviceID = sender.representedObject as? String else { return }
        viewModel.fetchApps(for: deviceID)
    }
    
    @objc private func mirrorDevice(_ sender: NSMenuItem) {
        guard let deviceID = sender.representedObject as? String else { return }
        viewModel.mirrorDevice(deviceID: deviceID)
    }
    
    @objc private func launchApp(_ sender: NSMenuItem) {
        guard let (deviceID, packageID) = sender.representedObject as? (String, String) else { return }
        viewModel.launchApp(packageID: packageID, deviceID: deviceID)
    }
    
    @objc private func showPreferences() {
        // As recommended, use the standard mechanism for opening the Settings scene.
        // This aligns with how SwiftUI's SettingsLink operates by sending standard actions.
        if #available(macOS 13, *) {
            // Use the modern selector for Settings (macOS 13+)
            NSApp.sendAction(Selector(("showSettingsWindow:")), to: nil, from: nil)
        } else {
            // Use the older selector for Preferences (macOS 12 and earlier)
            NSApp.sendAction(Selector(("showPreferencesWindow:")), to: nil, from: nil)
        }
        
        // Ensure the application is active and the settings window is brought to front
        NSApp.activate(ignoringOtherApps: true)
        

    }
}


